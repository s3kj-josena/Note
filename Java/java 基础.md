**java 中的数据类型：**

* 基本数据类型变量存的是：数据本身
* 引用类型变量存的是：保存数据的空间地址

常用的基本数据类型：

| 数据类型 | 说明 | 字节 | 应用 | 示例 |
| :---: | :---: | :---: | :--- | :--- |
| int | 整型 | 4 | 存储整数\(年龄、个数\) | int age = 21; |
| double | 双精度浮点型 | 8 | 存储小数\(价格、平均成绩\) | double price = 1.5; |
| float | 单精度浮点型 | 4 | 存储小数\(身高\) | float heitht = 155.5f; |
| char | 字符型 | 2 | 存储单个字符\(性别：'男'、'女'\) | char sex = '男' ; |
| boolean | 布尔型 | 1 | 表示"真"或"假"，取值只能为ture或false | boolean flag = ture; |

* 为 float 型变量赋值时在数值后添加字母
* 为 char 型变量赋值时使用单引号 ' ' 引起来

**java 中的自动类型转换：**

条件：

1. 目标类型能与源类型兼容（如 double 型兼容 int 型，但是 char 型不能兼容 int 型）
2. 目标类型大于源类型（如 double 类型长度为8字节，int 类型为4字节，因此 double 类型变量里直接可以存放 int 类型的数据，反过来不行）

**java 中的强制类型转换：**

语法：（数据类型）数值

```
double avg1 = 75.8;
int avg2 = (int)avg1;
```

强制转换的数值并不会四舍五入，而是直接将小数位截断，**强制类型转换可能会造成数据的丢失**

**java 常量的应用：**

```
final 常量名 = 值;  值被设定后，在程序运行过程中不允许改变
```

程序中使用常量可以提高代码的**可维护性，**常量名一般使用大写字符

**java 中的注释：**

规范的程序源代码中，注释应占源代码的1/3以上

单行注释：

```
//这是单行注释
```

多行注释：

```
/*
 * 这是多行注释
 * 可以包括多行内容
 */
```

文档注释：

```
/**
 * 这是文档注释
 * @author josena
 * @version v1.0
 */
```

**java 中的逻辑运算符：**

| 逻辑运算符 | 名称 | 举例 | 结果 |
| :---: | :---: | :---: | :--- |
| && | 与 | a && b | a 与 b 都为 ture 则返回 ture |
| \|\| | 或 | a \|\| b | a 与 b 任一为 ture 则返回 ture |
| ! | 非 | ! a | a 为 false 则返回 ture ，即取反 |
| ^ | 异或 | a ^ b | a 与 b 有且仅有一个为 ture 则返回 ture |

**java 中的条件运算符：**

条件运算符（ ? : ）也称“三元运算符”

语法：**布尔表达式 ? 表达式1 : 表达式2**

运算过程：如果布尔表达式的值为 ture ，则返回表达式1的值，否则返回表达式2的值

```
String str = (8>5) ? "8大于5" : "8不大于5";
System.out.println(str);
运行结果为：8大于5
```

**java 条件语句之 switch ：**

```
switch(表达式){
    case 值1:
        执行代码块1
        break;
    case 值2:
        执行代码块2
        break;
    ... ...
    default :
        默认执行的代码
}
```

当 switch 后表达式的值和 case 语句后的值相同时，从该位置开始向下执行，直到遇到 break 语句或者 switch 语句块结束；如果没有匹配的 case 语句则执行 default 块的代码

* switch 后面小括号中的表达式的值必须是**整型或字符型**
* case 后面的值可以是常量数值（如1、2），也可以是一个常量表达式（如2+2），但不能是变量或带有变量的表达式（如 a \*2）
* case 匹配后，执行匹配块里的程序代码，没有遇见 break 会继续执行下一个 case 块里的内容，直到遇到 break 语句或者 switch 语句块结束

```
int num = 1; //保存考试名次
switch(num){
    case 1:
        System.out.println("奖励笔记本一台");
    case 1:
        System.out.println("奖励IPAD 2一个");
    case 1:
        System.out.println("奖励移动电源一个");
    default:
        System.out.println("奖励U盘一个");
}
运行结果：
    奖励笔记本一台
    奖励IPAD 2一个
    奖励移动电源一个
    奖励U盘一个
```

也可以把功能相同的 case 语句合并起来：

```
case 1:
case 2:
        System.out.println("奖励笔记本一台");
```

default 块可以出现在任意位置，也可以省略

**java 循环语句之 while ：**

```
while(判断条件){
    循环操作
}
```

特点：先判断，后执行

1. 判断 while 后面的条件是否成立（ture/false）
2. 当条件成立时，执行循环内的操作代码
3. 重复1、2步骤，直到循环条件不成立为止

**java 循环语句之 do...while ：**

```
do {
    循环操作
} while(判断条件)
```

特点：先执行，后判断

1. 先执行一遍循环操作，然后判断循环条件是否成立
2. 如果条件成立，继续执行1、2步骤，直到循环条件不成立为止

do...while 语句保证循环**至少被执行一次**

**java 循环跳转语句之 continue ：**

```
//打印1--10之间所有的偶数，使用 continue 语句实现代码为：
for(int i=1;i<=10;i++){
    //判断 i 是否是偶数
    if (i%2!=0){
        continue; //通过 continue 结束本次循环，直接进行下一次循环
    }
    System.out.print(i+\t);
}

运行结果:2 4 6 8 10
```

**java 中的数组：**

**声明数组：**

语法：数据类型\[ \]  数组名;      / 或者：数据类型  数组名\[ \];

```
int[] scores; //存储学生成绩的数组，类型为整型
oduble heigth[];
String[] names;
```

**分配空间：**

语法：数组名=new  数据类型\[ 数组长度 \];

```
scores = new int[5]; //长度为5的整数数组
heigth = new double[5];
names = new String[5];
```

还可以将上面两个步骤合并，在声明数组的同事为它分配空间：

```
int[] scores = new int[5];
```

**赋值：**

数组中元素都是通过下标来访问的

```
scores[0]=89;
scores[1]=79;
```

**处理数组中数据：**

获取：

```
System.out.println("scores 数组中第一个元素的值："+scores[0]);
```

直接创建数组：（将声明数组、分配空间和赋值合并完成）

```
int[] scores={78,91,84,68};

它等价于：int[] scores=new int[]{78,91,84,68};
```

**使用 Arrays 类操作 java 中的数组：**

Arrays 类是 java 中提供的一个工具类，在 java.util 包中。使用 Arrays 类时必须导入 java.util.Arrays 包

Arrays 中常用的方法：

**排序：Arrays.sort\(数组名\);**

```
import java.util.Arrays;
public class HelloWorld{
    public static void main(String[] args){
        //定义一个整型数组
        int[] scores = {78,93,97,84,63};
        //使用 Arrays 类的 sort() 方法对数组进行排序
        Arrays.sort(scorts);
        System.out.println("排序后数组中元素的值：");
        //循环遍历输出数组中元素的值
        for(int i=0;i<scorts.length;i++){
            System.out.print("scores[i]"+\t);
        }
    }
}
运行结果：
        排序后数组中元素的值：
        63 78 84 93 97
```

**将数组转换为字符串：Arrays.toString\(数组名\);**

该方法按顺序把多个数组元素连接在一起，多个元素之间用逗号和空格隔开

```
import java.util.Arrays;
public static void main(String[] args){
    int[] nums = new int[]{25,7,126,53,14,86};
    System.out.println("输出数组 nums 中的的元素："+ Arrays.toString(nums));
}
运行结果：
        输出数组 nums 中的元素：25,7,126,53,14,86
```

**使用 foreach 操作数组：**

foreach 是 for 语句的特殊简化版本，在遍历数组、集合时，foreach 更简单便捷

```
for(元素类型 元素变量名 : 遍历对象){
    执行的代码
}

String[] hobbys = {"我","爱","你"};
for(String hobby : hobbys){
    System.out.print(hobby);
}
```

**java 中的二维数组：**

二维数组的每个数组空间保存的是一个一维数组

**声明数组并分配空间：**

```
数据类型[][] 数组名 = new 数据类型[行的个数][列的个数];
int[][] scores = new int[3][4]; //定义一个3行4列的二维数组

或者：
数据类型[][] 数组名;
数组名 = new 数据类型[行数][列数];
```

**赋值：**

```
数组名[行下标][列下标] = 值；
数据类型[][] 数组名 = {{值1,值2...},{值11,值22...},{值21,值22...}};
num[0][0] = 12;  //给第1行第1列的元素赋值
```

**处理数组：**

使用二重循环来输出二维数组中的每一个元素：

```
int[][] num = {{1,2,3},{4,5,6}};   //定义一个两行三列的二维数组并赋值
for(int i=0;i<num.length;i++){    //定位行
    for(int j=0;j<bum[i].length;j++){    //定位每行的元素
        System.out.print(num[i][j]);    //依次输出每个元素
    }
    System.out.println();    //每行打印结束要换行
}
运行结果：
        123
        456
```

**java 中方法的重载：**

1. 必须是在同一类中
2. 方法名相同
3. 方法参数的个数、顺序、类型不同
4. 与方法的修饰符或返回值没有关系

```
public void show(){}
public void show(String name){}
public void show(String name,int age){}
public void show(int age,String name){}
```

～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～\`～～～～

